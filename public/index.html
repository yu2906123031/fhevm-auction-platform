<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FHEVM æœºå¯†æ‹å–å¹³å°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.2) 0%, transparent 50%),
                linear-gradient(135deg, #0f0f23 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%);
            min-height: 100vh;
            color: #333;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 98px,
                    rgba(255, 255, 255, 0.03) 100px
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 98px,
                    rgba(255, 255, 255, 0.03) 100px
                );
            pointer-events: none;
            z-index: -1;
        }
        
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 10% 20%, rgba(0, 255, 255, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255, 0, 255, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 50% 50%, rgba(0, 255, 127, 0.05) 0%, transparent 30%);
            animation: aiGlow 8s ease-in-out infinite alternate;
            pointer-events: none;
            z-index: -1;
        }
        
        @keyframes aiGlow {
            0% {
                opacity: 0.3;
                transform: scale(1);
            }
            100% {
                opacity: 0.6;
                transform: scale(1.1);
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .nav-bar {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 15px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .nav-links a:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .wallet-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 24px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 0 20px rgba(120, 219, 255, 0.1);
            backdrop-filter: blur(25px);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
        }

        .card h2 {
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            text-shadow: 0 0 10px rgba(120, 219, 255, 0.3);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 5px rgba(120, 219, 255, 0.2);
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            color: rgba(255, 255, 255, 0.9);
            transition: all 0.3s ease;
        }
        
        .form-group input::placeholder,
        .form-group textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: rgba(120, 219, 255, 0.6);
            box-shadow: 
                0 0 0 3px rgba(120, 219, 255, 0.2),
                0 0 15px rgba(120, 219, 255, 0.3);
            background: rgba(255, 255, 255, 0.08);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            background: linear-gradient(135deg, rgba(120, 219, 255, 0.8) 0%, rgba(255, 119, 198, 0.8) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 4px 15px rgba(120, 219, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 25px rgba(120, 219, 255, 0.5),
                0 0 20px rgba(255, 119, 198, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #718096 0%, #4a5568 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status.success {
            background: #f0fff4;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #fc8181;
        }

        .status.info {
            background: #ebf8ff;
            color: #2a4365;
            border: 1px solid #90cdf4;
        }

        /* FHEVMåŠ è½½ç•Œé¢æ ·å¼ */
        .fhevm-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loader-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .loader-header h3 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        .loader-header p {
            color: #718096;
            margin-bottom: 30px;
        }

        .progress-container {
            margin-bottom: 30px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #78dbff 0%, #ff77c6 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            color: #4a5568;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .loader-actions {
            margin-bottom: 20px;
        }

        .loader-tips {
            background: #f7fafc;
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #78dbff;
        }

        .loader-tips p {
            color: #4a5568;
            margin: 0;
            font-size: 0.9rem;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
        }

        .auction-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.9));
            border: 1px solid rgba(255, 154, 158, 0.2);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1), 0 1px 8px rgba(0, 0, 0, 0.06);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .auction-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15), 0 5px 20px rgba(255, 154, 158, 0.2);
            border-color: rgba(255, 154, 158, 0.4);
        }

        .auction-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #ffeaa7 100%);
            opacity: 0.8;
        }

        .auction-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 154, 158, 0.03) 0%, transparent 70%);
            pointer-events: none;
            transition: opacity 0.3s ease;
            opacity: 0;
        }

        .auction-card:hover::after {
            opacity: 1;
        }

        .auction-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .auction-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .auction-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .auction-status.active {
            background: #c6f6d5;
            color: #22543d;
        }

        .auction-status.ended {
            background: #fed7d7;
            color: #742a2a;
        }

        .auction-status.settled {
            background: #bee3f8;
            color: #2a4365;
        }

        .auction-description {
            color: #4a5568;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .auction-details {
            background: #f7fafc;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .detail-row:last-child {
            margin-bottom: 0;
        }

        .detail-label {
            font-weight: 600;
            color: #4a5568;
        }

        .detail-value {
            color: #2d3748;
            font-weight: 500;
        }

        .price-highlight {
            color: #ff9a9e;
            font-weight: 700;
            font-size: 1.1rem;
        }

        .bid-section {
            border-top: 1px solid #e2e8f0;
            padding-top: 15px;
        }

        .bid-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .bid-input {
            flex: 1;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
        }

        .bid-input:focus {
            outline: none;
            border-color: #ff9a9e;
        }

        .countdown {
            background: #fff5f5;
            border: 1px solid #feb2b2;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            margin-bottom: 15px;
            font-weight: 600;
            color: #c53030;
        }

        .user-info {
            background: #f7fafc;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .user-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #ff9a9e;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #718096;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #ff9a9e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        /* åŠ è½½åŠ¨ç”»æ ·å¼ */
        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff9a9e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        .loading-container {
            text-align: center;
            padding: 40px 20px;
            background: #f7fafc;
            border-radius: 10px;
            margin: 20px 0;
        }

        .loading-container h3 {
            color: #4a5568;
            margin-bottom: 10px;
        }

        .loading-container p {
            color: #718096;
            margin-bottom: 20px;
        }

        .error-container {
            text-align: center;
            padding: 40px 20px;
            background: #fed7d7;
            border: 1px solid #feb2b2;
            border-radius: 10px;
            margin: 20px 0;
        }

        .error-container h3 {
            color: #c53030;
            margin-bottom: 10px;
        }

        .error-container p {
            color: #742a2a;
            margin-bottom: 20px;
        }

        .performance-info {
            background: #e6fffa;
            border: 1px solid #81e6d9;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #234e52;
        }

        .tabs {
            display: flex;
            background: #f7fafc;
            border-radius: 10px;
            padding: 5px;
            margin-bottom: 20px;
        }

        .tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .tab.active {
            background: white;
            color: #ff9a9e;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .nav-bar {
                flex-direction: column;
                gap: 15px;
            }

            .wallet-section {
                width: 100%;
                justify-content: center;
            }

            .bid-input-group {
                flex-direction: column;
            }

            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ›ï¸ FHEVM æœºå¯†æ‹å–å¹³å°</h1>
            <p>åŸºäºå®Œå…¨åŒæ€åŠ å¯†çš„éšç§ä¿æŠ¤æ‹å–ç³»ç»Ÿ</p>
        </div>

        <div class="nav-bar">
            <div class="nav-links">
                <a href="/">ğŸ  é¦–é¡µ</a>
                <a href="/auctions">ğŸ›ï¸ æ‹å–å¤§å…</a>
                <a href="/my-auctions">ğŸ“‹ æˆ‘çš„æ‹å–</a>
                <a href="/help">â“ å¸®åŠ©</a>
            </div>
            <div class="wallet-section">
                <button id="connectWallet" class="btn">è¿æ¥é’±åŒ…</button>
                <span id="walletAddress" class="hidden"></span>
            </div>
        </div>

        <div id="status" class="status hidden"></div>
        
        <!-- FHEVMåŠ è½½ç•Œé¢ -->
        <div id="fhevmLoader" class="fhevm-loader hidden">
            <div class="loader-content">
                <div class="loader-header">
                    <h3>ğŸ” æ­£åœ¨åˆå§‹åŒ–FHEVMåŠ å¯†åº“</h3>
                    <p>é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿæ—¶é—´...</p>
                </div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill"></div>
                    </div>
                    <div id="progressText" class="progress-text">0%</div>
                </div>
                <div class="loader-actions">
                    <button id="skipFhevm" class="btn btn-secondary">è·³è¿‡å¹¶ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼</button>
                </div>
                <div class="loader-tips">
                    <p>ğŸ’¡ æç¤ºï¼šFHEVMåº“æä¾›å®Œå…¨åŒæ€åŠ å¯†åŠŸèƒ½ï¼Œç¡®ä¿ç«æ‹ä»·æ ¼çš„éšç§æ€§</p>
                </div>
            </div>
        </div>

        <!-- ç”¨æˆ·ä¿¡æ¯ -->
        <div id="userInfo" class="card hidden">
            <h2>ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯</h2>
            <div class="user-info">
                <div class="user-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="userBalance">0</div>
                        <div class="stat-label">è´¦æˆ·ä½™é¢ (ETH)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="lockedFunds">0</div>
                        <div class="stat-label">é”å®šèµ„é‡‘ (ETH)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="myAuctions">0</div>
                        <div class="stat-label">æˆ‘çš„æ‹å–</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="myBids">0</div>
                        <div class="stat-label">æˆ‘çš„ç«æ‹</div>
                    </div>
                </div>
                <div style="margin-top: 15px; text-align: center;">
                    <button id="withdrawFunds" class="btn btn-warning">æå–å¯ç”¨èµ„é‡‘</button>
                </div>
            </div>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="card">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('auctions')">ğŸ›ï¸ æ‹å–åˆ—è¡¨</div>
                <div class="tab" onclick="switchTab('create')">â• åˆ›å»ºæ‹å–</div>
                <div class="tab" onclick="switchTab('manage')">âš™ï¸ ç®¡ç†</div>
            </div>

            <!-- æ‹å–åˆ—è¡¨ -->
            <div id="auctions" class="tab-content active">
                <div class="form-group">
                    <button id="loadAuctions" class="btn btn-secondary">åˆ·æ–°æ‹å–åˆ—è¡¨</button>
                </div>
                <div id="auctionsList" class="grid">
                    <!-- æ‹å–å°†åœ¨è¿™é‡ŒåŠ¨æ€åŠ è½½ -->
                </div>
            </div>

            <!-- åˆ›å»ºæ‹å– -->
            <div id="create" class="tab-content">
                <h2>åˆ›å»ºæ–°æ‹å–</h2>
                <div class="form-group">
                    <label for="itemName">ç‰©å“åç§°:</label>
                    <input type="text" id="itemName" placeholder="è¾“å…¥æ‹å–ç‰©å“åç§°">
                </div>
                <div class="form-group">
                    <label for="itemDescription">ç‰©å“æè¿°:</label>
                    <textarea id="itemDescription" placeholder="è¯¦ç»†æè¿°æ‹å–ç‰©å“..."></textarea>
                </div>
                <div class="form-group">
                    <label for="startingPrice">èµ·æ‹ä»·æ ¼ (ETH):</label>
                    <input type="number" id="startingPrice" placeholder="0.1" step="0.001" min="0">
                </div>
                <div class="form-group">
                    <label for="reservePrice">ä¿ç•™ä»·æ ¼ (ETH):</label>
                    <input type="number" id="reservePrice" placeholder="1.0" step="0.001" min="0">
                    <small style="color: #718096;">ä¿ç•™ä»·æ ¼å°†è¢«åŠ å¯†ï¼Œåªæœ‰è¾¾åˆ°æ­¤ä»·æ ¼æ‹å–æ‰ä¼šæˆåŠŸ</small>
                </div>
                <div class="form-group">
                    <label for="auctionDuration">æ‹å–æŒç»­æ—¶é—´ (å°æ—¶):</label>
                    <input type="number" id="auctionDuration" placeholder="24" min="1" max="168">
                </div>
                <button id="createAuction" class="btn">åˆ›å»ºæ‹å–</button>
            </div>

            <!-- ç®¡ç†é¢æ¿ -->
            <div id="manage" class="tab-content">
                <h2>æ‹å–ç®¡ç†</h2>
                <div id="adminPanel" class="hidden">
                    <h3>ç®¡ç†å‘˜åŠŸèƒ½</h3>
                    <div class="form-group">
                        <label for="platformFee">å¹³å°è´¹ç‡ (%):</label>
                        <input type="number" id="platformFee" placeholder="2" min="0" max="10" step="0.1">
                        <button id="setPlatformFee" class="btn btn-secondary">è®¾ç½®è´¹ç‡</button>
                    </div>
                    <div class="form-group">
                        <label for="emergencyAuctionId">ç´§æ€¥åœæ­¢æ‹å–ID:</label>
                        <input type="number" id="emergencyAuctionId" placeholder="0" min="0">
                        <button id="emergencyStop" class="btn btn-danger">ç´§æ€¥åœæ­¢</button>
                    </div>
                </div>
                
                <h3>å¹³å°ç»Ÿè®¡</h3>
                <div class="user-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalAuctions">0</div>
                        <div class="stat-label">æ€»æ‹å–æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="activeAuctions">0</div>
                        <div class="stat-label">æ´»è·ƒæ‹å–</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="platformFeeRate">0</div>
                        <div class="stat-label">å¹³å°è´¹ç‡ (%)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://unpkg.com/fhevmjs@0.4.1/bundle/index.js"></script>
    <script>
        let provider, signer, contract, fhevmInstance;
        let userAddress = null;
        let isOwner = false;
        let countdownIntervals = {};
        
        // é”™è¯¯å¤„ç†å’Œé‡è¯•é…ç½®
        const ERROR_CONFIG = {
            maxRetries: 3,
            retryDelay: 1000, // 1ç§’
            timeoutDuration: 15000, // 15ç§’
            networkCheckInterval: 30000 // 30ç§’
        };
        
        // è¿æ¥çŠ¶æ€ç®¡ç†
        let connectionState = {
            isConnected: false,
            lastError: null,
            retryCount: 0,
            networkStatus: 'unknown',
            lastSuccessfulCall: Date.now()
        };
        
        // é”™è¯¯åˆ†ç±»
        const ERROR_TYPES = {
            NETWORK: 'network',
            CONTRACT: 'contract',
            WALLET: 'wallet',
            TIMEOUT: 'timeout',
            USER: 'user',
            UNKNOWN: 'unknown'
        };

        // æ™ºèƒ½é‡è¯•æœºåˆ¶
        async function retryWithBackoff(fn, context = '', maxRetries = ERROR_CONFIG.maxRetries) {
            let lastError;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const result = await Promise.race([
                        fn(),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('æ“ä½œè¶…æ—¶')), ERROR_CONFIG.timeoutDuration)
                        )
                    ]);
                    
                    // æˆåŠŸæ—¶é‡ç½®é‡è¯•è®¡æ•°
                    connectionState.retryCount = 0;
                    connectionState.lastSuccessfulCall = Date.now();
                    return result;
                } catch (error) {
                    lastError = error;
                    const errorType = classifyError(error);
                    
                    console.warn(`${context} å°è¯• ${attempt}/${maxRetries} å¤±è´¥:`, {
                        error: error.message,
                        type: errorType,
                        code: error.code
                    });
                    
                    // å¦‚æœæ˜¯ç”¨æˆ·å–æ¶ˆæˆ–æŸäº›ä¸å¯é‡è¯•çš„é”™è¯¯ï¼Œç›´æ¥æŠ›å‡º
                    if (errorType === ERROR_TYPES.USER || 
                        error.code === 4001 || 
                        error.message?.includes('User denied') ||
                        attempt === maxRetries) {
                        break;
                    }
                    
                    // æŒ‡æ•°é€€é¿å»¶è¿Ÿ
                    const delay = ERROR_CONFIG.retryDelay * Math.pow(2, attempt - 1);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            
            connectionState.retryCount++;
            connectionState.lastError = lastError;
            throw lastError;
        }
        
        // é”™è¯¯åˆ†ç±»å‡½æ•°
        function classifyError(error) {
            const message = error.message?.toLowerCase() || '';
            const code = error.code;
            
            // ç”¨æˆ·æ“ä½œé”™è¯¯
            if (code === 4001 || message.includes('user denied') || message.includes('user rejected')) {
                return ERROR_TYPES.USER;
            }
            
            // ç½‘ç»œé”™è¯¯
            if (message.includes('network') || message.includes('connection') || 
                message.includes('timeout') || message.includes('fetch') ||
                code === 'NETWORK_ERROR' || code === 'TIMEOUT') {
                return ERROR_TYPES.NETWORK;
            }
            
            // åˆçº¦è°ƒç”¨é”™è¯¯
            if (message.includes('call_exception') || message.includes('execution reverted') ||
                message.includes('insufficient funds') || message.includes('gas') ||
                code === 'CALL_EXCEPTION' || code === 'UNPREDICTABLE_GAS_LIMIT') {
                return ERROR_TYPES.CONTRACT;
            }
            
            // é’±åŒ…é”™è¯¯
            if (message.includes('metamask') || message.includes('wallet') || 
                message.includes('provider') || code === 'UNSUPPORTED_OPERATION') {
                return ERROR_TYPES.WALLET;
            }
            
            // è¶…æ—¶é”™è¯¯
            if (message.includes('timeout') || message.includes('è¶…æ—¶')) {
                return ERROR_TYPES.TIMEOUT;
            }
            
            return ERROR_TYPES.UNKNOWN;
        }
        
        // ç½‘ç»œçŠ¶æ€ç›‘æ§
        function startNetworkMonitoring() {
            // ç›‘å¬åœ¨çº¿çŠ¶æ€å˜åŒ–
            window.addEventListener('online', () => {
                connectionState.networkStatus = 'online';
                showStatus('ç½‘ç»œè¿æ¥å·²æ¢å¤', 'success');
            });
            
            window.addEventListener('offline', () => {
                connectionState.networkStatus = 'offline';
                showStatus('ç½‘ç»œè¿æ¥å·²æ–­å¼€', 'error');
            });
            
            // å®šæœŸæ£€æŸ¥è¿æ¥çŠ¶æ€
            setInterval(async () => {
                if (connectionState.networkStatus !== 'offline') {
                    const isOnline = await checkNetworkConnection();
                    const newStatus = isOnline ? 'online' : 'offline';
                    
                    if (newStatus !== connectionState.networkStatus) {
                        connectionState.networkStatus = newStatus;
                        if (!isOnline) {
                            showStatus('ç½‘ç»œè¿æ¥ä¸ç¨³å®š', 'warning');
                        }
                    }
                }
            }, ERROR_CONFIG.networkCheckInterval);
        }
        
        // åˆçº¦é…ç½®
        let CONTRACT_ADDRESS = ''; // å°†åœ¨éƒ¨ç½²åå¡«å…¥
        const CONTRACT_ABI = [
            // AuctionPlatform ABI
            "function owner() view returns (address)",
            "function auctionCount() view returns (uint256)",
            "function platformFeePercentage() view returns (uint256)",
            "function createAuction(string memory title, string memory description, bytes32 encryptedReservePrice, bytes calldata inputProof, uint256 duration) external returns (uint256)",
            "function placeBid(uint256 auctionId, bytes32 encryptedBid, bytes calldata inputProof) external payable",
            "function getAuction(uint256 auctionId) view returns (tuple(uint256 id, string itemName, string itemDescription, address seller, uint256 startingPrice, uint256 creationTime, uint256 endTime, bool isActive, bool isSettled))",
            "function getBidCount(uint256 auctionId) view returns (uint256)",
            "function hasBid(uint256 auctionId, address bidder) view returns (bool)",
            "function bidderFunds(address bidder) view returns (uint256)",
            "function withdrawFunds() external",
            "function settleAuction(uint256 auctionId) external",
            "function emergencyStopAuction(uint256 auctionId) external",
            "function setPlatformFee(uint256 newFeePercentage) external",
            "function canSettleAuction(uint256 auctionId) view returns (bool)",
            "event AuctionCreated(uint256 indexed auctionId, address indexed seller, string itemName, uint256 endTime)",
            "event BidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 timestamp)",
            "event AuctionSettled(uint256 indexed auctionId, address indexed winner, bool successful)"
        ];

        // å…¨å±€é”™è¯¯å¤„ç†å™¨ - è¿‡æ»¤æ‰©å±•ç›¸å…³é”™è¯¯
        function setupGlobalErrorHandler() {
            // æ‰©å±•é”™è¯¯è¿‡æ»¤æ¨¡å¼
            const extensionPatterns = [
                'inject.js', 'inpage.js', 'contentScript.js', 'solana.js', 'btc.js', 'sui.js',
                'dapp-interface.js', 'solanaActionsContentScript.js', 'chrome-extension://',
                'moz-extension://', 'safari-extension://', 'Cannot destructure property',
                'Failed to execute \'observe\' on \'MutationObserver\'', 'ResizeObserver loop limit exceeded',
                'Non-Error promise rejection captured', 'Script error', 'Network request failed',
                'Loading chunk', 'Loading CSS chunk', 'ChunkLoadError',
                // æ–°å¢çš„é”™è¯¯è¿‡æ»¤æ¨¡å¼
                'bytehunter.cloud', 'url-whitelist.json', 'AxiosError',
                'Request failed with status code 451', 'Unavailable For Legal Reasons',
                'parameter 1 is not of type \'Node\'', 'extension://',
                'content_script', 'contentScript', 'chunk-', '.js:',
                'GET https://assets.bytehunter.cloud', 'XMLHttpRequest.send',
                'Promise.then', 'await in', 'Uncaught (in promise)'
            ];
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºæ‰©å±•é”™è¯¯
            function isExtensionError(error, filename, message, stack) {
                return extensionPatterns.some(pattern => {
                    return filename?.includes(pattern) || 
                           message?.includes(pattern) ||
                           stack?.includes(pattern) ||
                           error?.toString()?.includes(pattern);
                });
            }
            
            // å…¨å±€é”™è¯¯ç›‘å¬
            window.addEventListener('error', (event) => {
                if (isExtensionError(event.error, event.filename, event.message, event.error?.stack)) {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
                
                // è®°å½•åº”ç”¨ç›¸å…³é”™è¯¯
                console.error('åº”ç”¨é”™è¯¯:', {
                    message: event.message,
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    error: event.error,
                    timestamp: new Date().toISOString()
                });
                
                // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
                if (event.message && !event.message.includes('Script error')) {
                    showStatus('åº”ç”¨é‡åˆ°é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
                }
            });
            
            // å¤„ç†æœªæ•è·çš„Promiseæ‹’ç»
            window.addEventListener('unhandledrejection', (event) => {
                const reason = event.reason;
                const stack = reason?.stack || '';
                const message = reason?.message || reason?.toString() || '';
                
                if (isExtensionError(reason, '', message, stack)) {
                    event.preventDefault();
                    return;
                }
                
                console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', {
                    reason: reason,
                    stack: stack,
                    timestamp: new Date().toISOString()
                });
                
                // é˜²æ­¢æ˜¾ç¤ºè¿‡å¤šé”™è¯¯ä¿¡æ¯
                if (!message.includes('Loading') && !message.includes('Network')) {
                    showStatus('ç½‘ç»œæˆ–åŠ è½½é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥', 'warning');
                }
                
                event.preventDefault();
            });
            
            // æ§åˆ¶å°è­¦å‘Šè¿‡æ»¤
            const originalWarn = console.warn;
            console.warn = function(...args) {
                const message = args.join(' ');
                if (!isExtensionError(null, '', message, '')) {
                    originalWarn.apply(console, args);
                }
            };
        }

        // ç½‘ç»œè¿æ¥æ£€æµ‹
        function checkNetworkConnection() {
            return new Promise((resolve) => {
                if (!navigator.onLine) {
                    resolve(false);
                    return;
                }
                
                // å°è¯•è·å–ä¸€ä¸ªå°çš„èµ„æºæ¥æµ‹è¯•ç½‘ç»œ
                const img = new Image();
                const timeout = setTimeout(() => {
                    img.onload = img.onerror = null;
                    resolve(false);
                }, 3000);
                
                img.onload = () => {
                    clearTimeout(timeout);
                    resolve(true);
                };
                
                img.onerror = () => {
                    clearTimeout(timeout);
                    resolve(false);
                };
                
                // ä½¿ç”¨ä¸€ä¸ªå°çš„å›¾ç‰‡æ¥æµ‹è¯•è¿æ¥
                img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            });
        }
        
        // æ£€æŸ¥FHEVMåº“æ˜¯å¦å¯ç”¨
        function checkFhevmAvailability() {
            return new Promise((resolve) => {
                // å¿«é€Ÿæ£€æŸ¥FHEVMåº“æ˜¯å¦å·²ç»å­˜åœ¨
                if (typeof window.fhevm !== 'undefined') {
                    resolve(true);
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰FHEVMç›¸å…³çš„è„šæœ¬æ ‡ç­¾
                const scripts = document.querySelectorAll('script[src*="fhevm"], script[src*="tfhe"]');
                if (scripts.length === 0) {
                    resolve(false);
                    return;
                }
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´çœ‹åº“æ˜¯å¦ä¼šåŠ è½½
                let attempts = 0;
                const maxAttempts = 10; // 1ç§’æ£€æŸ¥
                
                const checkInterval = setInterval(() => {
                    attempts++;
                    if (typeof window.fhevm !== 'undefined') {
                        clearInterval(checkInterval);
                        resolve(true);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                        resolve(false);
                    }
                }, 100);
            });
        }
        
        // åˆå§‹åŒ–
        async function init() {
            try {
                setupGlobalErrorHandler();
                
                // å¯åŠ¨ç½‘ç»œç›‘æ§
                startNetworkMonitoring();
                
                // æ£€æŸ¥ç½‘ç»œè¿æ¥
                const isOnline = await checkNetworkConnection();
                if (!isOnline) {
                    showStatus('ç½‘ç»œè¿æ¥ä¸å¯ç”¨ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½å—é™', 'warning');
                }
                
                await loadConfig();
                
                // æ™ºèƒ½æ£€æŸ¥FHEVMåº“å¯ç”¨æ€§
                const fhevmAvailable = await checkFhevmAvailability();
                
                if (isOnline && fhevmAvailable) {
                    await initializeFHEVM();
                } else {
                    if (!fhevmAvailable) {
                        console.info('FHEVMåº“ä¸å¯ç”¨ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼');
                    } else {
                        console.info('ç½‘ç»œä¸å¯ç”¨ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼');
                    }
                    useFhevmSimulation();
                }
                
                setupEventListeners();
                showStatus('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', 'info');
                
                // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨åŠ è½½æ‹å–åˆ—è¡¨
                await loadAuctions();
                
                // è®¾ç½®ç½‘ç»œçŠ¶æ€ç›‘å¬
                window.addEventListener('online', () => {
                    connectionState.isOnline = true;
                    showStatus('ç½‘ç»œè¿æ¥å·²æ¢å¤', 'success');
                });
                
                window.addEventListener('offline', () => {
                    connectionState.isOnline = false;
                    showStatus('ç½‘ç»œè¿æ¥å·²æ–­å¼€ï¼Œåˆ‡æ¢åˆ°ç¦»çº¿æ¨¡å¼', 'warning');
                });
                
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                // å³ä½¿åˆå§‹åŒ–å¤±è´¥ï¼Œä¹Ÿè¦è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
                setupEventListeners();
                
                // å°è¯•ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼
                if (!fhevmInstance) {
                    useFhevmSimulation();
                }
                
                showStatus('ç³»ç»Ÿåˆå§‹åŒ–éƒ¨åˆ†å¤±è´¥ï¼Œå·²å¯ç”¨å¤‡ç”¨æ¨¡å¼', 'warning');
            }
        }

        // åŠ è½½é…ç½®
        async function loadConfig() {
            try {
                const response = await fetch('/config.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const config = await response.json();
                CONTRACT_ADDRESS = config.contractAddress;
                console.log('é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸï¼Œåˆçº¦åœ°å€:', CONTRACT_ADDRESS);
            } catch (error) {
                console.warn('æ— æ³•åŠ è½½é…ç½®æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®:', error.message);
                // ä½¿ç”¨é»˜è®¤åˆçº¦åœ°å€
                CONTRACT_ADDRESS = '0x00a0c4c5a6c83578dd19db328b3d8381519221fe';
            }
        }

        // æ˜¾ç¤ºFHEVMåŠ è½½ç•Œé¢
        function showFhevmLoader() {
            const loader = document.getElementById('fhevmLoader');
            loader.classList.remove('hidden');
            
            // ç»‘å®šè·³è¿‡æŒ‰é’®äº‹ä»¶
            document.getElementById('skipFhevm').onclick = () => {
                hideFhevmLoader();
                useFhevmSimulation();
            };
        }
        
        // éšè—FHEVMåŠ è½½ç•Œé¢
        function hideFhevmLoader() {
            const loader = document.getElementById('fhevmLoader');
            loader.classList.add('hidden');
        }
        
        // æ›´æ–°åŠ è½½è¿›åº¦
        function updateFhevmProgress(percent, text) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            progressFill.style.width = percent + '%';
            progressText.textContent = text;
        }
        
        // ä½¿ç”¨FHEVMæ¨¡æ‹Ÿæ¨¡å¼
        function useFhevmSimulation() {
            fhevmInstance = {
                encrypt64: (value) => {
                    const hash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(value.toString()));
                    return {
                        handles: [hash],
                        inputProof: '0x',
                        // ä¸ºäº†å…¼å®¹åˆçº¦è°ƒç”¨ï¼Œç›´æ¥è¿”å›hashä½œä¸ºeinput
                        valueOf: () => hash,
                        toString: () => hash
                    };
                },
                isSimulated: true
            };
            console.log('ä½¿ç”¨FHEVMæ¨¡æ‹Ÿå®ä¾‹ï¼Œåº”ç”¨åŠŸèƒ½å¯æ­£å¸¸ä½¿ç”¨');
            showStatus('å·²åˆ‡æ¢åˆ°æ¨¡æ‹Ÿæ¨¡å¼ï¼ŒåŠŸèƒ½æ­£å¸¸å¯ç”¨', 'info');
        }

        // åˆå§‹åŒ–FHEVM
        async function initializeFHEVM() {
            showFhevmLoader();
            updateFhevmProgress(10, '10% - æ£€æŸ¥FHEVMåº“...');
            
            let retryCount = 0;
            const maxRetries = 2;
            
            while (retryCount <= maxRetries) {
                try {
                    // æ£€æŸ¥FHEVMåº“æ˜¯å¦å·²åŠ è½½
                    if (typeof window.fhevm === 'undefined') {
                        updateFhevmProgress(20, '20% - ç­‰å¾…FHEVMåº“åŠ è½½...');
                        
                        // é™é»˜ç­‰å¾…FHEVMåº“åŠ è½½ï¼Œä¸è¾“å‡ºè¿‡å¤šæ—¥å¿—
                        await new Promise((resolve, reject) => {
                            let attempts = 0;
                            const maxAttempts = 50; // 5ç§’è¶…æ—¶
                            
                            const checkFhevm = () => {
                                attempts++;
                                const progress = 20 + (attempts / maxAttempts) * 30;
                                updateFhevmProgress(progress, `${Math.round(progress)}% - åŠ è½½FHEVMåº“...`);
                                
                                if (typeof window.fhevm !== 'undefined') {
                                    resolve();
                                } else if (attempts >= maxAttempts) {
                                    reject(new Error('FHEVMåº“åŠ è½½è¶…æ—¶'));
                                } else {
                                    setTimeout(checkFhevm, 100);
                                }
                            };
                            checkFhevm();
                        });
                    }
                    
                    updateFhevmProgress(60, '60% - åˆå§‹åŒ–FHEVMå®ä¾‹...');
                    
                    // å°è¯•åˆ›å»ºFHEVMå®ä¾‹
                    const createInstancePromise = window.fhevm.createInstance({
                        chainId: 11155111, // Sepoliaæµ‹è¯•ç½‘
                        networkUrl: 'https://sepolia.infura.io/v3/YOUR_INFURA_KEY',
                        gatewayUrl: 'https://gateway.sepolia.zama.ai'
                    });
                    
                    // è®¾ç½®åˆ›å»ºå®ä¾‹çš„è¶…æ—¶
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('FHEVMå®ä¾‹åˆ›å»ºè¶…æ—¶')), 8000); // 8ç§’è¶…æ—¶
                    });
                    
                    updateFhevmProgress(80, '80% - åˆ›å»ºFHEVMå®ä¾‹...');
                    fhevmInstance = await Promise.race([createInstancePromise, timeoutPromise]);
                    
                    updateFhevmProgress(100, '100% - åˆå§‹åŒ–å®Œæˆ!');
                    
                    setTimeout(() => {
                        hideFhevmLoader();
                        showStatus('FHEVMåˆå§‹åŒ–æˆåŠŸï¼Œéšç§ä¿æŠ¤å·²å¯ç”¨', 'success');
                    }, 500);
                    
                    return; // æˆåŠŸé€€å‡º
                    
                } catch (error) {
                    retryCount++;
                    
                    if (retryCount <= maxRetries) {
                        updateFhevmProgress(30, `é‡è¯•ä¸­... (${retryCount}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, 2000)); // ç­‰å¾…2ç§’åé‡è¯•
                        continue;
                    }
                    
                    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥ï¼Œé™é»˜åˆ‡æ¢åˆ°æ¨¡æ‹Ÿæ¨¡å¼
                    updateFhevmProgress(100, 'åˆ‡æ¢åˆ°æ¨¡æ‹Ÿæ¨¡å¼');
                    
                    setTimeout(() => {
                        hideFhevmLoader();
                        useFhevmSimulation();
                    }, 1000);
                    break;
                }
            }
        }

        // è¿æ¥é’±åŒ…ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        async function connectWallet() {
            const connectBtn = document.getElementById('connectWallet');
            const originalText = connectBtn.textContent;
            
            try {
                connectBtn.textContent = 'è¿æ¥ä¸­...';
                connectBtn.disabled = true;
                
                await retryWithBackoff(async () => {
                    // æ£€æŸ¥MetaMaskæ˜¯å¦å®‰è£…
                    if (typeof window.ethereum === 'undefined') {
                        throw new Error('è¯·å®‰è£…MetaMaské’±åŒ…ã€‚è®¿é—® https://metamask.io ä¸‹è½½å®‰è£…ã€‚');
                    }
                    
                    // æ£€æŸ¥ç½‘ç»œè¿æ¥
                    const isOnline = await checkNetworkConnection();
                    if (!isOnline) {
                        throw new Error('ç½‘ç»œè¿æ¥ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®');
                    }
                    
                    // è¯·æ±‚è´¦æˆ·è®¿é—®æƒé™
                    const accounts = await window.ethereum.request({ 
                        method: 'eth_requestAccounts' 
                    });
                    
                    if (!accounts || accounts.length === 0) {
                        throw new Error('æœªè·å–åˆ°è´¦æˆ·ä¿¡æ¯ï¼Œè¯·ç¡®ä¿MetaMaskå·²è§£é”');
                    }
                    
                    // åˆ›å»ºproviderå’Œsigner
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    userAddress = await signer.getAddress();
                    
                    // æ£€æŸ¥ç½‘ç»œ
                    const network = await provider.getNetwork();
                    console.log('å½“å‰ç½‘ç»œ:', network);
                    
                    return { accounts, network };
                }, 'é’±åŒ…è¿æ¥', 2); // é’±åŒ…è¿æ¥æœ€å¤šé‡è¯•2æ¬¡
                
                // å°è¯•è¿æ¥åˆçº¦ï¼ˆç‹¬ç«‹å¤„ç†ï¼Œå¤±è´¥ä¸å½±å“é’±åŒ…è¿æ¥ï¼‰
                if (CONTRACT_ADDRESS) {
                    try {
                        await retryWithBackoff(async () => {
                            contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                            await checkUserRole();
                        }, 'åˆçº¦è¿æ¥', 2);
                    } catch (contractError) {
                        console.warn('åˆçº¦è¿æ¥å¤±è´¥ï¼Œä½†é’±åŒ…è¿æ¥æˆåŠŸ:', contractError.message);
                        showStatus('é’±åŒ…è¿æ¥æˆåŠŸï¼Œä½†åˆçº¦æš‚æ—¶ä¸å¯ç”¨', 'warning');
                    }
                }
                
                // æ›´æ–°UIå’ŒåŠ è½½ç”¨æˆ·ä¿¡æ¯
                updateWalletUI();
                
                try {
                    await loadUserInfo();
                } catch (infoError) {
                    console.warn('åŠ è½½ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', infoError.message);
                }
                
                connectionState.isConnected = true;
                showStatus('é’±åŒ…è¿æ¥æˆåŠŸ', 'success');
                
                // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨ï¼ˆåªè®¾ç½®ä¸€æ¬¡ï¼‰
                setupWalletEventListeners();
                
            } catch (error) {
                console.error('é’±åŒ…è¿æ¥å¤±è´¥:', error);
                
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                connectBtn.textContent = originalText;
                connectBtn.disabled = false;
                
                // åˆ†ç±»é”™è¯¯å¹¶æä¾›å‹å¥½ä¿¡æ¯
                const errorType = classifyError(error);
                let errorMessage = error.message;
                
                switch (errorType) {
                    case ERROR_TYPES.USER:
                        errorMessage = 'ç”¨æˆ·å–æ¶ˆäº†è¿æ¥æ“ä½œ';
                        break;
                    case ERROR_TYPES.NETWORK:
                        errorMessage = 'ç½‘ç»œè¿æ¥é—®é¢˜ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®';
                        break;
                    case ERROR_TYPES.WALLET:
                        errorMessage = 'MetaMaské’±åŒ…é—®é¢˜ï¼Œè¯·æ£€æŸ¥é’±åŒ…çŠ¶æ€';
                        break;
                    case ERROR_TYPES.TIMEOUT:
                        errorMessage = 'è¿æ¥è¶…æ—¶ï¼Œè¯·é‡è¯•';
                        break;
                    default:
                        if (error.code === -32002) {
                            errorMessage = 'MetaMaskæ­£åœ¨å¤„ç†è¯·æ±‚ï¼Œè¯·æ£€æŸ¥MetaMaskçª—å£';
                        }
                }
                
                showStatus('é’±åŒ…è¿æ¥å¤±è´¥: ' + errorMessage, 'error');
            }
        }
        
        // è®¾ç½®é’±åŒ…äº‹ä»¶ç›‘å¬å™¨
        function setupWalletEventListeners() {
            // é¿å…é‡å¤ç»‘å®š
            if (window.ethereum._listenersSetup) return;
            window.ethereum._listenersSetup = true;
            
            // ç›‘å¬è´¦æˆ·å˜åŒ–
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    // ç”¨æˆ·æ–­å¼€è¿æ¥
                    resetWalletState();
                    showStatus('é’±åŒ…å·²æ–­å¼€è¿æ¥', 'info');
                    setTimeout(() => location.reload(), 1000);
                } else {
                    // è´¦æˆ·åˆ‡æ¢
                    showStatus('æ£€æµ‹åˆ°è´¦æˆ·åˆ‡æ¢ï¼Œæ­£åœ¨é‡æ–°åŠ è½½...', 'info');
                    setTimeout(() => location.reload(), 500);
                }
            });
            
            // ç›‘å¬ç½‘ç»œå˜åŒ–
            window.ethereum.on('chainChanged', (chainId) => {
                console.log('ç½‘ç»œå·²åˆ‡æ¢:', chainId);
                showStatus('æ£€æµ‹åˆ°ç½‘ç»œåˆ‡æ¢ï¼Œæ­£åœ¨é‡æ–°åŠ è½½...', 'info');
                setTimeout(() => location.reload(), 500);
            });
        }
        
        // é‡ç½®é’±åŒ…çŠ¶æ€
        function resetWalletState() {
            userAddress = null;
            contract = null;
            provider = null;
            signer = null;
            isOwner = false;
            connectionState.isConnected = false;
        }

        // æ£€æŸ¥ç”¨æˆ·è§’è‰²ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        async function checkUserRole() {
            if (!contract || !userAddress) return;
            
            try {
                await retryWithBackoff(async () => {
                    const owner = await contract.owner();
                    isOwner = userAddress.toLowerCase() === owner.toLowerCase();
                    
                    if (isOwner) {
                        document.getElementById('adminPanel').classList.remove('hidden');
                    }
                }, 'æ£€æŸ¥ç”¨æˆ·è§’è‰²', 2);
            } catch (error) {
                console.warn('æ£€æŸ¥ç”¨æˆ·è§’è‰²å¤±è´¥:', error.message);
                // è§’è‰²æ£€æŸ¥å¤±è´¥ä¸å½±å“å…¶ä»–åŠŸèƒ½ï¼Œé™é»˜å¤„ç†
            }
        }

        // æ›´æ–°é’±åŒ…UI
        function updateWalletUI() {
            const connectBtn = document.getElementById('connectWallet');
            const addressSpan = document.getElementById('walletAddress');
            
            if (userAddress) {
                connectBtn.textContent = 'å·²è¿æ¥';
                connectBtn.disabled = true;
                addressSpan.textContent = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                addressSpan.classList.remove('hidden');
                document.getElementById('userInfo').classList.remove('hidden');
            }
        }

        // åŠ è½½ç”¨æˆ·ä¿¡æ¯ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        async function loadUserInfo() {
            if (!userAddress) return;

            try {
                // åŠ è½½é’±åŒ…ä½™é¢ï¼ˆåŸºç¡€åŠŸèƒ½ï¼Œä¼˜å…ˆçº§é«˜ï¼‰
                if (provider) {
                    await retryWithBackoff(async () => {
                        const balance = await provider.getBalance(userAddress);
                        document.getElementById('userBalance').textContent = 
                            parseFloat(ethers.utils.formatEther(balance)).toFixed(4);
                    }, 'åŠ è½½é’±åŒ…ä½™é¢', 2);
                }
                
                // åŠ è½½åˆçº¦ç›¸å…³ä¿¡æ¯ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
                if (contract) {
                    try {
                        await retryWithBackoff(async () => {
                            const lockedFunds = await contract.bidderFunds(userAddress);
                            document.getElementById('lockedFunds').textContent = 
                                parseFloat(ethers.utils.formatEther(lockedFunds)).toFixed(4);
                        }, 'åŠ è½½é”å®šèµ„é‡‘', 2);
                    } catch (contractError) {
                        console.warn('åŠ è½½é”å®šèµ„é‡‘å¤±è´¥:', contractError.message);
                        document.getElementById('lockedFunds').textContent = '0.0000';
                    }
                }
                
                // åŠ è½½å¹³å°ç»Ÿè®¡ï¼ˆç‹¬ç«‹å¤„ç†ï¼‰
                try {
                    await loadPlatformStats();
                } catch (statsError) {
                    console.warn('åŠ è½½å¹³å°ç»Ÿè®¡å¤±è´¥:', statsError.message);
                }
                
            } catch (error) {
                console.warn('åŠ è½½ç”¨æˆ·ä¿¡æ¯éƒ¨åˆ†å¤±è´¥:', error.message);
                // è®¾ç½®é»˜è®¤å€¼
                document.getElementById('userBalance').textContent = '0.0000';
                document.getElementById('lockedFunds').textContent = '0.0000';
            }
        }

        // åŠ è½½å¹³å°ç»Ÿè®¡ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        async function loadPlatformStats() {
            if (!contract) {
                // è®¾ç½®é»˜è®¤å€¼
                document.getElementById('totalAuctions').textContent = '0';
                document.getElementById('platformFeeRate').textContent = '0';
                document.getElementById('activeAuctions').textContent = '0';
                return;
            }

            try {
                // åˆ†æ­¥åŠ è½½ï¼Œé¿å…å•ç‚¹å¤±è´¥å½±å“æ‰€æœ‰æ•°æ®
                let auctionCount = 0;
                let platformFee = 0;
                let activeCount = 0;
                
                // åŠ è½½åŸºç¡€ç»Ÿè®¡
                try {
                    await retryWithBackoff(async () => {
                        auctionCount = await contract.auctionCount();
                        platformFee = await contract.platformFeePercentage();
                        
                        document.getElementById('totalAuctions').textContent = auctionCount.toString();
                        document.getElementById('platformFeeRate').textContent = platformFee.toString();
                    }, 'åŠ è½½åŸºç¡€ç»Ÿè®¡', 2);
                } catch (basicError) {
                    console.warn('åŠ è½½åŸºç¡€ç»Ÿè®¡å¤±è´¥:', basicError.message);
                    document.getElementById('totalAuctions').textContent = '0';
                    document.getElementById('platformFeeRate').textContent = '0';
                }
                
                // è®¡ç®—æ´»è·ƒæ‹å–æ•°ï¼ˆå¯é€‰åŠŸèƒ½ï¼Œå¤±è´¥ä¸å½±å“å…¶ä»–æ•°æ®ï¼‰
                if (auctionCount > 0) {
                    try {
                        await retryWithBackoff(async () => {
                            const batchSize = 10; // æ‰¹é‡å¤„ç†ï¼Œé¿å…ä¸€æ¬¡æ€§æŸ¥è¯¢è¿‡å¤š
                            const totalCount = auctionCount.toNumber();
                            
                            for (let i = 0; i < totalCount; i += batchSize) {
                                const endIndex = Math.min(i + batchSize, totalCount);
                                const promises = [];
                                
                                for (let j = i; j < endIndex; j++) {
                                    promises.push(
                                        contract.getAuction(j).catch(err => {
                                            console.warn(`è·å–æ‹å– ${j} å¤±è´¥:`, err.message);
                                            return null;
                                        })
                                    );
                                }
                                
                                const auctions = await Promise.all(promises);
                                auctions.forEach(auction => {
                                    if (auction && auction.isActive) {
                                        activeCount++;
                                    }
                                });
                            }
                            
                            document.getElementById('activeAuctions').textContent = activeCount.toString();
                        }, 'è®¡ç®—æ´»è·ƒæ‹å–', 1); // åªé‡è¯•1æ¬¡
                    } catch (activeError) {
                        console.warn('è®¡ç®—æ´»è·ƒæ‹å–å¤±è´¥:', activeError.message);
                        document.getElementById('activeAuctions').textContent = '0';
                    }
                } else {
                    document.getElementById('activeAuctions').textContent = '0';
                }
                
            } catch (error) {
                console.warn('åŠ è½½å¹³å°ç»Ÿè®¡å¤±è´¥:', error.message);
                // è®¾ç½®é»˜è®¤å€¼
                document.getElementById('totalAuctions').textContent = '0';
                document.getElementById('platformFeeRate').textContent = '0';
                document.getElementById('activeAuctions').textContent = '0';
            }
        }

        // åˆ›å»ºæ‹å–ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        async function createAuction() {
            if (!contract || !userAddress) {
                showStatus('è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            if (!connectionState.isOnline) {
                showStatus('ç½‘ç»œè¿æ¥ä¸å¯ç”¨ï¼Œæ— æ³•åˆ›å»ºæ‹å–', 'error');
                return;
            }

            const itemName = document.getElementById('itemName').value.trim();
            const itemDescription = document.getElementById('itemDescription').value.trim();
            const startingPrice = document.getElementById('startingPrice').value;
            const reservePrice = document.getElementById('reservePrice').value;
            const duration = document.getElementById('auctionDuration').value;

            // è¾“å…¥éªŒè¯
            if (!itemName || !itemDescription || !startingPrice || !reservePrice || !duration) {
                showStatus('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯', 'error');
                return;
            }

            // ä»·æ ¼éªŒè¯
            try {
                const startingPriceNum = parseFloat(startingPrice);
                const reservePriceNum = parseFloat(reservePrice);
                const durationNum = parseInt(duration);
                
                if (startingPriceNum <= 0 || reservePriceNum <= 0 || durationNum <= 0) {
                    showStatus('ä»·æ ¼å’Œæ—¶é•¿å¿…é¡»å¤§äº0', 'error');
                    return;
                }
                
                if (reservePriceNum < startingPriceNum) {
                    showStatus('ä¿ç•™ä»·æ ¼ä¸èƒ½ä½äºèµ·å§‹ä»·æ ¼', 'error');
                    return;
                }
                
                if (durationNum > 168) { // æœ€é•¿7å¤©
                    showStatus('æ‹å–æ—¶é•¿ä¸èƒ½è¶…è¿‡168å°æ—¶ï¼ˆ7å¤©ï¼‰', 'error');
                    return;
                }
            } catch (validationError) {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨åˆ›å»ºæ‹å–...', 'info');
                
                // ä½¿ç”¨æ™ºèƒ½é‡è¯•æœºåˆ¶åˆ›å»ºæ‹å–
                await retryWithBackoff(async () => {
                    const startingPriceWei = ethers.utils.parseEther(startingPrice);
                    const reservePriceWei = ethers.utils.parseEther(reservePrice);
                    const durationInSeconds = parseInt(duration) * 60 * 60;
                    
                    // åŠ å¯†ä¿ç•™ä»·æ ¼
                    const encryptedReservePrice = fhevmInstance.encrypt64(reservePriceWei.toString());
                    
                    // ç¡®ä¿ inputProof ä¸ä¸ºç©º
                    const inputProof = encryptedReservePrice.inputProof || '0x00';
                    
                    console.log('åˆ›å»ºæ‹å–å‚æ•°:', {
                        itemName,
                        itemDescription,
                        encryptedReservePrice: encryptedReservePrice.handles[0],
                        inputProof,
                        durationInSeconds
                    });
                    
                    // å‘é€äº¤æ˜“
                    const tx = await contract.createAuction(
                        itemName,
                        itemDescription,
                        encryptedReservePrice.handles[0],
                        inputProof,
                        durationInSeconds
                    );
                    
                    showStatus('äº¤æ˜“å·²å‘é€ï¼Œç­‰å¾…ç¡®è®¤...', 'info');
                    
                    // ç­‰å¾…äº¤æ˜“ç¡®è®¤ï¼Œè®¾ç½®è¶…æ—¶
                    const receipt = await Promise.race([
                        tx.wait(),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('äº¤æ˜“ç¡®è®¤è¶…æ—¶')), 60000) // 60ç§’è¶…æ—¶
                        )
                    ]);
                    
                    if (!receipt.status) {
                        throw new Error('äº¤æ˜“æ‰§è¡Œå¤±è´¥');
                    }
                    
                    return receipt;
                }, 'åˆ›å»ºæ‹å–', 2);
                
                showStatus('æ‹å–åˆ›å»ºæˆåŠŸ', 'success');
                
                // æ¸…ç©ºè¡¨å•
                document.getElementById('itemName').value = '';
                document.getElementById('itemDescription').value = '';
                document.getElementById('startingPrice').value = '';
                document.getElementById('reservePrice').value = '';
                document.getElementById('auctionDuration').value = '';
                
                // åˆ‡æ¢åˆ°æ‹å–åˆ—è¡¨å¹¶åˆ·æ–°
                switchTab('auctions');
                
                // å»¶è¿Ÿåˆ·æ–°ï¼Œç¡®ä¿åŒºå—é“¾çŠ¶æ€æ›´æ–°
                setTimeout(async () => {
                    await loadAuctions();
                }, 2000);
                
            } catch (error) {
                console.error('åˆ›å»ºæ‹å–å¤±è´¥:', error);
                
                const errorType = classifyError(error);
                let errorMessage = error.message;
                
                if (errorType === ERROR_TYPES.NETWORK) {
                    errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•';
                } else if (errorType === ERROR_TYPES.CONTRACT) {
                    errorMessage = 'åˆçº¦äº¤äº’å¤±è´¥ï¼Œè¯·æ£€æŸ¥é’±åŒ…è¿æ¥';
                } else if (errorType === ERROR_TYPES.USER_REJECTED) {
                    errorMessage = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“';
                } else if (error.message.includes('insufficient funds')) {
                    errorMessage = 'ä½™é¢ä¸è¶³ï¼Œè¯·ç¡®ä¿æœ‰è¶³å¤Ÿçš„ETHæ”¯ä»˜gasè´¹ç”¨';
                } else if (error.message.includes('timeout') || error.message.includes('è¶…æ—¶')) {
                    errorMessage = 'æ“ä½œè¶…æ—¶ï¼Œè¯·é‡è¯•';
                }
                
                showStatus('åˆ›å»ºæ‹å–å¤±è´¥: ' + errorMessage, 'error');
            }
        }

        // æµ‹è¯•æ‹å–æ•°æ®
        const testAuctions = [
            {
                id: 0,
                itemName: "ğŸ¨ æ•°å­—è‰ºæœ¯ä½œå“ - æ˜Ÿç©ºå¹»æƒ³",
                itemDescription: "ç”±çŸ¥åæ•°å­—è‰ºæœ¯å®¶åˆ›ä½œçš„é™é‡ç‰ˆNFTä½œå“ï¼Œå±•ç°äº†å®‡å®™æ˜Ÿç©ºçš„ç¥ç§˜ä¸ç¾ä¸½ã€‚é‡‡ç”¨4Kåˆ†è¾¨ç‡ï¼ŒåŒ…å«åŠ¨æ€æ•ˆæœã€‚",
                seller: "0x1234567890123456789012345678901234567890",
                startingPrice: ethers.utils.parseEther("0.1"),
                creationTime: Math.floor(Date.now() / 1000) - 3600,
                endTime: Math.floor(Date.now() / 1000) + 86400,
                isActive: true,
                isSettled: false
            },
            {
                id: 1,
                itemName: "âŒš é™é‡ç‰ˆæ™ºèƒ½æ‰‹è¡¨",
                itemDescription: "å…¨æ–°æœªæ‹†å°çš„é™é‡ç‰ˆæ™ºèƒ½æ‰‹è¡¨ï¼Œå…·å¤‡å¥åº·ç›‘æµ‹ã€GPSå®šä½ã€é˜²æ°´ç­‰åŠŸèƒ½ã€‚å…¨çƒé™é‡1000å°ã€‚",
                seller: "0x2345678901234567890123456789012345678901",
                startingPrice: ethers.utils.parseEther("0.5"),
                creationTime: Math.floor(Date.now() / 1000) - 7200,
                endTime: Math.floor(Date.now() / 1000) + 172800,
                isActive: true,
                isSettled: false
            },
            {
                id: 2,
                itemName: "ğŸ“š ç¨€æœ‰å¤ç±æ”¶è—",
                itemDescription: "19ä¸–çºªçš„çè´µå¤ç±ï¼Œä¿å­˜å®Œå¥½ï¼Œå…·æœ‰æé«˜çš„æ”¶è—ä»·å€¼ã€‚ç»è¿‡ä¸“ä¸šé‰´å®šï¼Œç¡®è®¤ä¸ºçœŸå“ã€‚",
                seller: "0x3456789012345678901234567890123456789012",
                startingPrice: ethers.utils.parseEther("2.0"),
                creationTime: Math.floor(Date.now() / 1000) - 10800,
                endTime: Math.floor(Date.now() / 1000) + 259200,
                isActive: true,
                isSettled: false
            },
            {
                id: 3,
                itemName: "ğŸ† ä½“è‚²çºªå¿µå“",
                itemDescription: "è‘—åè¿åŠ¨å‘˜ç­¾åçš„é™é‡ç‰ˆçƒè¡£ï¼Œé™„å¸¦å®˜æ–¹è®¤è¯è¯ä¹¦ã€‚å¯¹ä½“è‚²æ”¶è—çˆ±å¥½è€…æ¥è¯´æ˜¯çè´µçš„æ”¶è—å“ã€‚",
                seller: "0x4567890123456789012345678901234567890123",
                startingPrice: ethers.utils.parseEther("0.8"),
                creationTime: Math.floor(Date.now() / 1000) - 14400,
                endTime: Math.floor(Date.now() / 1000) + 345600,
                isActive: true,
                isSettled: false
            },
            {
                id: 4,
                itemName: "ğŸ’ ç²¾ç¾ç å®é¦–é¥°",
                itemDescription: "æ‰‹å·¥åˆ¶ä½œçš„ç²¾ç¾é¡¹é“¾ï¼Œé•¶åµŒå¤©ç„¶å®çŸ³ï¼Œè®¾è®¡ç‹¬ç‰¹ã€‚é™„å¸¦ç å®é‰´å®šè¯ä¹¦ï¼Œç¡®ä¿å“è´¨ã€‚",
                seller: "0x5678901234567890123456789012345678901234",
                startingPrice: ethers.utils.parseEther("1.5"),
                creationTime: Math.floor(Date.now() / 1000) - 18000,
                endTime: Math.floor(Date.now() / 1000) + 432000,
                isActive: true,
                isSettled: false
            },
            {
                id: 5,
                itemName: "ğŸ® å¤å¤æ¸¸æˆæœº",
                itemDescription: "80å¹´ä»£ç»å…¸æ¸¸æˆæœºï¼ŒåŠŸèƒ½å®Œå¥½ï¼ŒåŒ…å«åŸè£…æ‰‹æŸ„å’Œå¤šæ¬¾ç»å…¸æ¸¸æˆå¡å¸¦ã€‚æ€€æ—§æ¸¸æˆçˆ±å¥½è€…çš„æœ€çˆ±ã€‚",
                seller: "0x6789012345678901234567890123456789012345",
                startingPrice: ethers.utils.parseEther("0.3"),
                creationTime: Math.floor(Date.now() / 1000) - 21600,
                endTime: Math.floor(Date.now() / 1000) + 518400,
                isActive: true,
                isSettled: false
            }
        ];

        // æ€§èƒ½ç›‘æ§
        const performanceMonitor = {
            startTime: null,
            
            start(operation) {
                this.startTime = performance.now();
                console.log(`å¼€å§‹æ‰§è¡Œ: ${operation}`);
            },
            
            end(operation) {
                if (this.startTime) {
                    const duration = performance.now() - this.startTime;
                    console.log(`${operation} å®Œæˆï¼Œè€—æ—¶: ${duration.toFixed(2)}ms`);
                    this.startTime = null;
                    return duration;
                }
            }
        };
        
        // åŠ è½½æ‹å–åˆ—è¡¨ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        async function loadAuctions() {
            performanceMonitor.start('åŠ è½½æ‹å–åˆ—è¡¨');
            
            try {
                showStatus('æ­£åœ¨åŠ è½½æ‹å–...', 'info');
                
                const auctionsList = document.getElementById('auctionsList');
                
                // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
                auctionsList.innerHTML = `
                    <div class="loading-container" style="text-align: center; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: #666;">æ­£åœ¨åŠ è½½æ‹å–æ•°æ®...</p>
                    </div>
                `;

                // å¦‚æœåˆçº¦å¯ç”¨ï¼Œå°è¯•åŠ è½½çœŸå®æ•°æ®
                if (contract && connectionState.isOnline) {
                    try {
                        // ä½¿ç”¨æ™ºèƒ½é‡è¯•æœºåˆ¶åŠ è½½æ‹å–æ•°é‡
                        const auctionCount = await retryWithBackoff(async () => {
                            return await Promise.race([
                                contract.auctionCount(),
                                new Promise((_, reject) => 
                                    setTimeout(() => reject(new Error('åˆçº¦è°ƒç”¨è¶…æ—¶')), 8000)
                                )
                            ]);
                        }, 'è·å–æ‹å–æ•°é‡', 2);
                        
                        if (auctionCount.gt(0)) {
                            auctionsList.innerHTML = ''; // æ¸…é™¤åŠ è½½åŠ¨ç”»
                            
                            let myAuctionsCount = 0;
                            let myBidsCount = 0;
                            const loadPromises = [];
                            const batchSize = 5; // æ‰¹é‡å¤„ç†å¤§å°
                            const totalCount = auctionCount.toNumber();

                            // åˆ†æ‰¹åŠ è½½æ‹å–æ•°æ®ï¼Œé¿å…ä¸€æ¬¡æ€§åŠ è½½è¿‡å¤š
                            for (let i = totalCount - 1; i >= 0; i -= batchSize) {
                                const batchPromises = [];
                                const startIndex = Math.max(0, i - batchSize + 1);
                                
                                for (let j = i; j >= startIndex; j--) {
                                    const loadPromise = retryWithBackoff(async () => {
                                        try {
                                            const [auction, hasBid, bidCount] = await Promise.all([
                                                contract.getAuction(j),
                                                userAddress ? contract.hasBid(j, userAddress).catch(() => false) : Promise.resolve(false),
                                                contract.getBidCount(j).catch(() => ({ toString: () => '0' }))
                                            ]);
                                            
                                            if (userAddress && auction.seller.toLowerCase() === userAddress.toLowerCase()) {
                                                myAuctionsCount++;
                                            }
                                            if (hasBid) {
                                                myBidsCount++;
                                            }

                                            return { auction, i: j, hasBid, bidCount };
                                        } catch (error) {
                                            const errorType = classifyError(error);
                                            if (errorType === ERROR_TYPES.NETWORK) {
                                                throw error; // ç½‘ç»œé”™è¯¯éœ€è¦é‡è¯•
                                            }
                                            console.warn(`åŠ è½½æ‹å– ${j} å¤±è´¥:`, error.message);
                                            return null;
                                        }
                                    }, `åŠ è½½æ‹å–${j}`, 1).catch(error => {
                                        console.warn(`æ‹å– ${j} é‡è¯•å¤±è´¥:`, error.message);
                                        return null;
                                    });
                                    
                                    batchPromises.push(loadPromise);
                                }
                                
                                // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                                const batchResults = await Promise.all(batchPromises);
                                loadPromises.push(...batchResults);
                                
                                // æ‰¹æ¬¡é—´çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…è¿‡è½½
                                if (i > startIndex) {
                                    await new Promise(resolve => setTimeout(resolve, 100));
                                }
                            }
                            
                            // æ¸²æŸ“æ‹å–å¡ç‰‡
                            const validResults = loadPromises.filter(result => result !== null);
                            validResults.forEach(({ auction, i, hasBid, bidCount }) => {
                                const auctionCard = createAuctionCard(auction, i, hasBid, bidCount);
                                auctionsList.appendChild(auctionCard);
                            });

                            // æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
                            document.getElementById('myAuctions').textContent = myAuctionsCount.toString();
                            document.getElementById('myBids').textContent = myBidsCount.toString();
                            
                            const duration = performanceMonitor.end('åŠ è½½æ‹å–åˆ—è¡¨');
                            const successCount = validResults.length;
                            const failCount = totalCount - successCount;
                            
                            if (failCount > 0) {
                                showStatus(`æ‹å–åŠ è½½å®Œæˆ (${successCount}/${totalCount}ä¸ªæˆåŠŸï¼Œ${failCount}ä¸ªå¤±è´¥ï¼Œè€—æ—¶${duration.toFixed(0)}ms)`, 'warning');
                            } else {
                                showStatus(`æ‹å–åŠ è½½å®Œæˆ (${successCount}ä¸ªæ‹å–ï¼Œè€—æ—¶${duration.toFixed(0)}ms)`, 'success');
                            }
                            return;
                        }
                    } catch (error) {
                        const errorType = classifyError(error);
                        console.warn('åŠ è½½åˆçº¦æ•°æ®å¤±è´¥ï¼Œä½¿ç”¨æµ‹è¯•æ•°æ®:', error.message);
                        
                        if (errorType === ERROR_TYPES.NETWORK) {
                            showStatus('ç½‘ç»œè¿æ¥é—®é¢˜ï¼Œæ­£åœ¨ä½¿ç”¨æµ‹è¯•æ•°æ®', 'warning');
                        } else {
                            showStatus('åˆçº¦è¿æ¥é—®é¢˜ï¼Œæ­£åœ¨ä½¿ç”¨æµ‹è¯•æ•°æ®', 'warning');
                        }
                    }
                }
                
                // ä½¿ç”¨æµ‹è¯•æ•°æ®
                auctionsList.innerHTML = ''; // æ¸…é™¤åŠ è½½åŠ¨ç”»
                
                // æ¨¡æ‹ŸåŠ è½½å»¶è¿Ÿä»¥å±•ç¤ºåŠ è½½çŠ¶æ€
                await new Promise(resolve => setTimeout(resolve, 500));
                
                testAuctions.forEach((auction, index) => {
                    const bidCount = { toString: () => Math.floor(Math.random() * 10) + 1 };
                    const hasBid = Math.random() > 0.7; // 30% æ¦‚ç‡å·²å‚ä¸ç«æ‹
                    const auctionCard = createAuctionCard(auction, index, hasBid, bidCount, true);
                    auctionsList.appendChild(auctionCard);
                });
                
                // æ›´æ–°æµ‹è¯•ç»Ÿè®¡æ•°æ®
                document.getElementById('myAuctions').textContent = '2';
                document.getElementById('myBids').textContent = '3';
                
                const duration = performanceMonitor.end('åŠ è½½æ‹å–åˆ—è¡¨');
                showStatus(`æ¼”ç¤ºæ•°æ®åŠ è½½å®Œæˆ (æµ‹è¯•æ¨¡å¼ï¼Œè€—æ—¶${duration.toFixed(0)}ms)`, 'info');
                
            } catch (error) {
                console.error('åŠ è½½æ‹å–å¤±è´¥:', error);
                
                const errorType = classifyError(error);
                let errorMessage = error.message;
                let retryText = 'é‡è¯•';
                
                if (errorType === ERROR_TYPES.NETWORK) {
                    errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®';
                    retryText = 'æ£€æŸ¥ç½‘ç»œå¹¶é‡è¯•';
                } else if (errorType === ERROR_TYPES.CONTRACT) {
                    errorMessage = 'åˆçº¦è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥é’±åŒ…è¿æ¥';
                    retryText = 'é‡æ–°è¿æ¥é’±åŒ…';
                }
                
                // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
                const auctionsList = document.getElementById('auctionsList');
                auctionsList.innerHTML = `
                    <div class="error-container" style="text-align: center; padding: 40px; color: #e53e3e;">
                        <h3>åŠ è½½å¤±è´¥</h3>
                        <p>${errorMessage}</p>
                        <button onclick="loadAuctions()" class="btn btn-primary" style="margin-top: 20px;">${retryText}</button>
                    </div>
                `;
                
                performanceMonitor.end('åŠ è½½æ‹å–åˆ—è¡¨');
                showStatus('åŠ è½½æ‹å–å¤±è´¥: ' + errorMessage, 'error');
            }
        }

        // åˆ›å»ºæ‹å–å¡ç‰‡
        function createAuctionCard(auction, auctionId, hasBid, bidCount, isTestMode = false) {
            const card = document.createElement('div');
            card.className = 'auction-card';
            
            const now = Math.floor(Date.now() / 1000);
            const isActive = auction.isActive && now < auction.endTime;
            const isOwner = userAddress && auction.seller.toLowerCase() === userAddress.toLowerCase();
            const canBid = isActive && !isOwner && userAddress;

            let statusClass = 'ended';
            let statusText = 'å·²ç»“æŸ';
            if (auction.isSettled) {
                statusClass = 'settled';
                statusText = 'å·²ç»“ç®—';
            } else if (isActive) {
                statusClass = 'active';
                statusText = 'è¿›è¡Œä¸­';
            }

            const timeRemaining = auction.endTime - now;
            const countdownId = `countdown-${auctionId}`;

            card.innerHTML = `
                <div class="auction-header">
                    <div class="auction-title">${auction.itemName}</div>
                    <div class="auction-status ${statusClass}">${statusText}</div>
                </div>
                <div class="auction-description">${auction.itemDescription}</div>
                <div class="auction-details">
                    <div class="detail-row">
                        <span class="detail-label">å–å®¶:</span>
                        <span class="detail-value">${auction.seller.slice(0, 6)}...${auction.seller.slice(-4)}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">èµ·æ‹ä»·:</span>
                        <span class="detail-value price-highlight">${ethers.utils.formatEther(auction.startingPrice)} ETH</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">ç«æ‹æ¬¡æ•°:</span>
                        <span class="detail-value">${bidCount.toString()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">åˆ›å»ºæ—¶é—´:</span>
                        <span class="detail-value">${new Date(auction.creationTime * 1000).toLocaleString()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">ç»“æŸæ—¶é—´:</span>
                        <span class="detail-value">${new Date(auction.endTime * 1000).toLocaleString()}</span>
                    </div>
                    ${hasBid ? '<div class="detail-row"><span class="detail-label" style="color: #48bb78; font-weight: 600;">âœ… å·²å‚ä¸ç«æ‹</span></div>' : ''}
                </div>
                ${isActive ? `<div id="${countdownId}" class="countdown"></div>` : ''}
                ${canBid ? `
                    <div class="bid-section">
                        <div class="bid-input-group">
                            <input type="number" id="bidAmount-${auctionId}" class="bid-input" placeholder="å‡ºä»·é‡‘é¢ (ETH)" step="0.001" min="${ethers.utils.formatEther(auction.startingPrice)}">
                            <button class="btn" onclick="${isTestMode ? 'demoPlaceBid' : 'placeBid'}(${auctionId})">${isTestMode ? 'æ¼”ç¤ºå‡ºä»·' : 'å‡ºä»·'}</button>
                        </div>
                    </div>
                ` : ''}
                ${isOwner && !auction.isSettled ? `
                    <div class="bid-section">
                        <button class="btn btn-success" onclick="${isTestMode ? 'demoSettleAuction' : 'settleAuction'}(${auctionId})">${isTestMode ? 'æ¼”ç¤ºç»“ç®—' : 'ç»“ç®—æ‹å–'}</button>
                    </div>
                ` : ''}
                ${isTestMode && !canBid && !isOwner ? `
                    <div class="bid-section">
                        <button class="btn btn-secondary" onclick="showStatus('è¿™æ˜¯æ¼”ç¤ºæ¨¡å¼ï¼Œè¯·è¿æ¥é’±åŒ…ä½“éªŒçœŸå®åŠŸèƒ½', 'info')">è¿æ¥é’±åŒ…å‚ä¸</button>
                    </div>
                ` : ''}
            `;

            // å¯åŠ¨å€’è®¡æ—¶
            if (isActive && timeRemaining > 0) {
                startCountdown(countdownId, timeRemaining);
            }

            return card;
        }

        // å¯åŠ¨å€’è®¡æ—¶
        function startCountdown(elementId, timeRemaining) {
            const element = document.getElementById(elementId);
            if (!element) return;

            const updateCountdown = () => {
                if (timeRemaining <= 0) {
                    element.textContent = 'æ‹å–å·²ç»“æŸ';
                    clearInterval(countdownIntervals[elementId]);
                    return;
                }

                const hours = Math.floor(timeRemaining / 3600);
                const minutes = Math.floor((timeRemaining % 3600) / 60);
                const seconds = timeRemaining % 60;

                element.textContent = `å‰©ä½™æ—¶é—´: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timeRemaining--;
            };

            updateCountdown();
            countdownIntervals[elementId] = setInterval(updateCountdown, 1000);
        }

        // å‡ºä»·
        async function placeBid(auctionId) {
            if (!contract || !userAddress) {
                showStatus('è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            const bidAmountInput = document.getElementById(`bidAmount-${auctionId}`);
            const bidAmount = bidAmountInput.value;

            if (!bidAmount || parseFloat(bidAmount) <= 0) {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„å‡ºä»·é‡‘é¢', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨æäº¤å‡ºä»·...', 'info');
                
                const bidAmountWei = ethers.utils.parseEther(bidAmount);
                
                // åŠ å¯†å‡ºä»·é‡‘é¢
                const encryptedBid = fhevmInstance.encrypt64(bidAmountWei.toString());
                
                const tx = await contract.placeBid(
                    auctionId,
                    encryptedBid.handles[0],
                    encryptedBid.inputProof,
                    { value: bidAmountWei }
                );
                
                await tx.wait();
                showStatus('å‡ºä»·æäº¤æˆåŠŸ', 'success');
                
                // æ¸…ç©ºè¾“å…¥æ¡†å¹¶åˆ·æ–°
                bidAmountInput.value = '';
                await loadAuctions();
                await loadUserInfo();
            } catch (error) {
                console.error('å‡ºä»·å¤±è´¥:', error);
                showStatus('å‡ºä»·å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ç»“ç®—æ‹å–
        async function settleAuction(auctionId) {
            if (!contract || !userAddress) {
                showStatus('è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨ç»“ç®—æ‹å–...', 'info');
                
                const tx = await contract.settleAuction(auctionId);
                await tx.wait();
                
                showStatus('æ‹å–ç»“ç®—æˆåŠŸ', 'success');
                await loadAuctions();
                await loadUserInfo();
            } catch (error) {
                console.error('ç»“ç®—å¤±è´¥:', error);
                showStatus('ç»“ç®—å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ¼”ç¤ºæ¨¡å¼å‡ºä»·
        function demoPlaceBid(auctionId) {
            const bidAmountInput = document.getElementById(`bidAmount-${auctionId}`);
            const bidAmount = bidAmountInput.value;

            if (!bidAmount || parseFloat(bidAmount) <= 0) {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„å‡ºä»·é‡‘é¢', 'error');
                return;
            }

            showStatus(`æ¼”ç¤ºå‡ºä»·æˆåŠŸï¼å‡ºä»·é‡‘é¢: ${bidAmount} ETH`, 'success');
            bidAmountInput.value = '';
            
            // æ¨¡æ‹Ÿæ›´æ–°ç«æ‹æ¬¡æ•°
            setTimeout(() => {
                showStatus('è¿™æ˜¯æ¼”ç¤ºæ¨¡å¼ï¼Œè¿æ¥é’±åŒ…åå¯ä½“éªŒçœŸå®åŠŸèƒ½', 'info');
            }, 2000);
        }

        // æ¼”ç¤ºæ¨¡å¼ç»“ç®—
         function demoSettleAuction(auctionId) {
             showStatus('æ¼”ç¤ºç»“ç®—æˆåŠŸï¼', 'success');
             setTimeout(() => {
                 showStatus('è¿™æ˜¯æ¼”ç¤ºæ¨¡å¼ï¼Œè¿æ¥é’±åŒ…åå¯ä½“éªŒçœŸå®åŠŸèƒ½', 'info');
             }, 2000);
         }

        // æå–èµ„é‡‘
        async function withdrawFunds() {
            if (!contract || !userAddress) {
                showStatus('è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨æå–èµ„é‡‘...', 'info');
                
                const tx = await contract.withdrawFunds();
                await tx.wait();
                
                showStatus('èµ„é‡‘æå–æˆåŠŸ', 'success');
                await loadUserInfo();
            } catch (error) {
                console.error('æå–èµ„é‡‘å¤±è´¥:', error);
                showStatus('æå–èµ„é‡‘å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è®¾ç½®å¹³å°è´¹ç‡
        async function setPlatformFee() {
            if (!contract || !isOwner) {
                showStatus('åªæœ‰ç®¡ç†å‘˜å¯ä»¥è®¾ç½®å¹³å°è´¹ç‡', 'error');
                return;
            }

            const feePercentage = document.getElementById('platformFee').value;
            if (!feePercentage || parseFloat(feePercentage) < 0 || parseFloat(feePercentage) > 10) {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„è´¹ç‡ (0-10%)', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨è®¾ç½®å¹³å°è´¹ç‡...', 'info');
                
                const tx = await contract.setPlatformFee(Math.floor(parseFloat(feePercentage) * 100));
                await tx.wait();
                
                showStatus('å¹³å°è´¹ç‡è®¾ç½®æˆåŠŸ', 'success');
                await loadPlatformStats();
            } catch (error) {
                console.error('è®¾ç½®å¹³å°è´¹ç‡å¤±è´¥:', error);
                showStatus('è®¾ç½®å¹³å°è´¹ç‡å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ç´§æ€¥åœæ­¢æ‹å–
        async function emergencyStopAuction() {
            if (!contract || !isOwner) {
                showStatus('åªæœ‰ç®¡ç†å‘˜å¯ä»¥ç´§æ€¥åœæ­¢æ‹å–', 'error');
                return;
            }

            const auctionId = document.getElementById('emergencyAuctionId').value;
            if (!auctionId || parseInt(auctionId) < 0) {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„æ‹å–ID', 'error');
                return;
            }

            try {
                showStatus('æ­£åœ¨ç´§æ€¥åœæ­¢æ‹å–...', 'info');
                
                const tx = await contract.emergencyStopAuction(parseInt(auctionId));
                await tx.wait();
                
                showStatus('æ‹å–å·²ç´§æ€¥åœæ­¢', 'success');
                await loadAuctions();
            } catch (error) {
                console.error('ç´§æ€¥åœæ­¢å¤±è´¥:', error);
                showStatus('ç´§æ€¥åœæ­¢å¤±è´¥: ' + error.message, 'error');
            }
        }

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabName) {
            // éšè—æ‰€æœ‰æ ‡ç­¾å†…å®¹
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„æ´»è·ƒçŠ¶æ€
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾å†…å®¹
            document.getElementById(tabName).classList.add('active');
            
            // æ¿€æ´»é€‰ä¸­çš„æ ‡ç­¾
            event.target.classList.add('active');
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.classList.remove('hidden');
            
            setTimeout(() => {
                statusDiv.classList.add('hidden');
            }, 5000);
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('createAuction').addEventListener('click', createAuction);
            document.getElementById('loadAuctions').addEventListener('click', loadAuctions);
            document.getElementById('withdrawFunds').addEventListener('click', withdrawFunds);
            document.getElementById('setPlatformFee').addEventListener('click', setPlatformFee);
            document.getElementById('emergencyStop').addEventListener('click', emergencyStopAuction);

            // ç›‘å¬è´¦æˆ·å˜åŒ–
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', (accounts) => {
                    if (accounts.length === 0) {
                        location.reload();
                    } else {
                        location.reload();
                    }
                });

                window.ethereum.on('chainChanged', () => {
                    location.reload();
                });
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init);

        // å…¨å±€å‡½æ•°ï¼Œä¾›HTMLè°ƒç”¨
        window.placeBid = placeBid;
        window.settleAuction = settleAuction;
        window.switchTab = switchTab;
    </script>
</body>
</html>